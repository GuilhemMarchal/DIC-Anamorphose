import numpy as np
import matplotlib.pyplot as plt

a = -1
b = 0
c = 1
Pos = np.array([1,0,-1])
R=1

def plot_implicit(fn, bbox=(0,2.5)):
    ''' create a plot of an implicit function
    fn  ...implicit function (plot where fn==0)
    bbox ..the x,y,and z limits of plotted interval'''
    xmin, xmax, ymin, ymax, zmin, zmax = bbox*3
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    A = np.linspace(xmin, xmax, 100) # resolution of the contour
    B = np.linspace(xmin, xmax, 15) # number of slices
    A1,A2 = np.meshgrid(A,A) # grid on which the contour is plotted

    for z in B: # plot contours in the XY plane
        X,Y = A1,A2
        Z = fn(X,Y,z)
        cset = ax.contour(X, Y, Z+z, [z], zdir='z')
        # [z] defines the only level to plot for this contour for this value of z

    for y in B: # plot contours in the XZ plane
        X,Z = A1,A2
        Y = fn(X,y,Z)
        cset = ax.contour(X, Y+y, Z, [y], zdir='y')

    for x in B: # plot contours in the YZ plane
        Y,Z = A1,A2
        X = fn(x,Y,Z)
        cset = ax.contour(X+x, Y, Z, [x], zdir='x')

    # must set plot limits because the contour will likely extend
    # way beyond the displayed level.  Otherwise matplotlib extends the plot limits
    # to encompass all values in the contour.
    plt.show()

def cylinder(x,y,z):
    return (x-Pos[0])**2 + (z-Pos[2])**2 + (y-Pos[1])**2 - (a*(x-Pos[0]) + b*(y-Pos[1]) + c*(z-Pos[2]))**2/(a**2+b**2+c**2) - R**2
def cone(x,y,z):
    Pos, R,a,b,c,alpha = np.array([1,0,-1]), 1, -1,0,1, np.pi/4
    return (x-Pos[0])**2 + (np.tan(alpha)**2)*(z-Pos[2])**2 + (y-Pos[1])**2 - (a*(x-Pos[0]) + b*(y-Pos[1]) + c*(np.tan(alpha)**2)*(z-Pos[2]))**2/(a**2+b**2+c**2) - R**2
def a(x,y,z):
    return x**2-y**2-(z*np.tan(np.pi/4))**2
plot_implicit(a)
